


通过第一个例子，我们知道Future接口提供了方法来检测异步计算是否已经结束（使用
isDone方法），等待异步操作结束，以及获取计算的结果。但是这些特性还不足以让你编写简洁
的并发代码。比如，我们很难表述Future结果之间的依赖性；从文字描述上这很简单，“当长时
间计算任务完成时，请将该计算的结果通知到另一个长时间运行的计算任务，这两个计算任务都
完成后，将计算的结果与另一个查询操作结果合并”。但是，使用Future中提供的方法完成这样
的操作又是另外一回事。这也是我们需要更具描述能力的特性的原因，比如下面这些。
 将两个异步计算合并为一个——这两个异步计算之间相互独立，同时第二个又依赖于第
一个的结果。
 等待Future集合中的所有任务都完成。
 仅等待Future集合中最快结束的任务完成（有可能因为它们试图通过不同的方式计算同
一个值），并返回它的结果。
 通过编程方式完成一个Future任务的执行（即以手工设定异步操作结果的方式）。
 应对Future的完成事件（即当Future的完成事件发生时会收到通知，并能使用Future
计算的结果进行下一步的操作，不只是简单地阻塞等待操作的结果）。
这一章中，你会了解新的CompletableFuture类（它实现了Future接口）如何利用Java 8
的新特性以更直观的方式将上述需求都变为可能。Stream和CompletableFuture的设计都遵循
了类似的模式：它们都使用了Lambda表达式以及流水线的思想。从这个角度，你可以说
CompletableFuture和Future的关系就跟Stream和Collection的关系一样。



