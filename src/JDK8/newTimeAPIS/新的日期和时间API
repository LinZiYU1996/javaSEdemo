


Java的API提供了很多有用的组件，能帮助你构建复杂的应用。不过，Java API也不总是完美
的。我们相信大多数有经验的程序员都会赞同Java 8之前的库对日期和时间的支持就非常不理想。
然而，你也不用太担心：Java 8中引入全新的日期和时间API就是要解决这一问题。
在Java 1.0中，对日期和时间的支持只能依赖java.util.Date类。正如类名所表达的，这
个类无法表示日期，只能以毫秒的精度表示时间。更糟糕的是它的易用性，由于某些原因未知的
设计决策，这个类的易用性被深深地损害了，比如：年份的起始选择是1900年，月份的起始从0
开始。这意味着，如果你想要用Date表示Java 8的发布日期，即2014年3月18日，需要创建下面
这样的Date实例：
Date date = new Date(114, 2, 18);
它的打印输出效果为：
Tue Mar 18 00:00:00 CET 2014
看起来不那么直观，不是吗？此外，甚至Date类的toString方法返回的字符串也容易误导
人。以我们的例子而言，它的返回值中甚至还包含了JVM的默认时区CET，即中欧时间（Central
Europe Time）。但这并不表示Date类在任何方面支持时区。
随着Java 1.0退出历史舞台，Date类的种种问题和限制几乎一扫而光，但很明显，这些历史
旧账如果不牺牲前向兼容性是无法解决的。所以，在Java 1.1中，Date类中的很多方法被废弃了，
取而代之的是java.util.Calendar类。很不幸，Calendar类也有类似的问题和设计缺陷，导
致使用这些方法写出的代码非常容易出错。比如，月份依旧是从0开始计算（不过，至少Calendar
类拿掉了由1900年开始计算年份这一设计）。更糟的是，同时存在Date和Calendar这两个类，



也增加了程序员的困惑。到底该使用哪一个类呢？此外，有的特性只在某一个类有提供，比如用
于以语言无关方式格式化和解析日期或时间的DateFormat方法就只在Date类里有。
DateFormat方法也有它自己的问题。比如，它不是线程安全的。这意味着两个线程如果尝
试使用同一个formatter解析日期，你可能会得到无法预期的结果。
最后，Date和Calendar类都是可以变的。能把2014年3月18日修改成4月18日意味着什么
呢？这种设计会将你拖入维护的噩梦，接下来的一章，我们会讨论函数式编程，你在该章中会了
解到更多的细节。
所有这些缺陷和不一致导致用户们转投第三方的日期和时间库，比如Joda-Time。为了解决
这些问题，Oracle决定在原生的Java API中提供高质量的日期和时间支持。所以，你会看到Java 8
在java.time包中整合了很多Joda-Time的特性。