
归约
怎样用map和reduce方法数一数流中有多少个菜呢？
答案：要解决这个问题，你可以把流中每个元素都映射成数字1，然后用reduce求和。这
相当于按顺序数流中的元素个数。
int count = menu.stream()
 .map(d -> 1)
 .reduce(0, (a, b) -> a + b);


 map和reduce的连接通常称为map-reduce模式，因Google用它来进行网络搜索而出名，
 因为它很容易并行化。请注意，在第4章中我们也看到了内置count方法可用来计算流中元素
 的个数：
 long count = menu.stream().count();


 归约方法的优势与并行化
 相比于前面写的逐步迭代求和，使用reduce的好处在于，这里的迭代被内部迭代抽象掉
 了，这让内部实现得以选择并行执行reduce操作。而迭代式求和例子要更新共享变量sum，
 这不是那么容易并行化的。如果你加入了同步，很可能会发现线程竞争抵消了并行本应带来的
 性能提升！这种计算的并行化需要另一种办法：将输入分块，分块求和，最后再合并起来。但
 这样的话代码看起来就完全不一样了。你在第7章会看到使用分支/合并框架来做是什么样子。
 但现在重要的是要认识到，可变的累加器模式对于并行化来说是死路一条。你需要一种新的模
 式，这正是reduce所提供的。你还将在第7章看到，使用流来对所有的元素并行求和时，你的
 代码几乎不用修改：stream()换成了parallelStream()。
 int sum = numbers.parallelStream().reduce(0, Integer::sum);
 但要并行执行这段代码也要付一定代价，我们稍后会向你解释：传递给reduce的Lambda
 不能更改状态（如实例变量），而且操作必须满足结合律才可以按任意顺序执行



