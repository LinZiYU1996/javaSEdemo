


“没有可感知的副作用”（不改变对调用者可见的变量、不进行I/O、不抛出异常）的这些限
制都隐含着引用透明性。如果一个函数只要传递同样的参数值，总是返回同样的结果，那这个
函数就是引用透明的。String.replace方法就是引用透明的，因为像"raoul".replace('r',
'R')这样的调用总是返回同样的结果（replace方法返回一个新的字符串，用小写的r替换掉
所有大写的R），而不是更新它的this对象，所以它可以被看成函数式的。
换句话说，函数无论在何处、何时调用，如果使用同样的输入总能持续地得到相同的结果，
就具备了函数式的特征。这也解释了我们为什么不把Random.nextInt看成函数式的方法。Java
语言中，使用Scanner对象从用户的键盘读取输入也违反了引用透明性原则，因为每次调用
nextLine时都可能得到不同的结果。不过，将两个final int类型的变量相加总能得到同样的
结果，因为在这种声明方式下，变量的内容是不会被改变的。
引用透明性是理解程序的一个重要属性。它还包含了对代价昂贵或者需长时间计算才能得到
结果的变量值的优化（通过保存机制而不是重复计算），我们通常将其称为记忆化或者缓存。虽
然重要，但是现在讨论还是有些跑题，我们会在14.5节进行介绍。


Java语言中，关于引用透明性还有一个比较复杂的问题。假设你对一个返回列表的方法调用
了两次。这两次调用会返回内存中的两个不同列表，不过它们包含了相同的元素。如果这些列表
被当作可变的对象值（因此是不相同的），那么该方法就不是引用透明的。如果你计划将这些列
表作为单纯的值（不可修改），那么把这些值看成相同的是合理的，这种情况下该方法是引用透
明的。通常情况下，在函数式编程中，你应该选择使用引用透明的函数。