



纯粹的函数式编程语言通常不包含像while或者for这样的迭代构造器。为什么呢？因为这
种类型的构造器经常隐藏着陷阱，诱使你修改对象。比如，while循环中，循环的条件需要更新；
否则循环就一次都不会执行，要么就进入无限循环的状态。但是，很多情况下循环还是非常有用
的。我们在前面的介绍中已经声明过，如果没有人能感知的话，函数式也允许进行变更，这意味
着我们可以修改局部变量。我们在Java中使用的for-each循环，for(Apple a : apples { }
如果用迭代器方式重写，代码如下：
Iterator<Apple> it = apples.iterator();
while (it.hasNext()) {
 Apple apple = it.next();
 // ...
}
这并不是问题，因为改变发生时，这些变化（包括使用next方法对迭代器状态的改变以及
在while循环内部对apple变量的赋值）对于方法的调用方是不可见的。但是，如果使用
for-each循环，比如像下面这个搜索算法就会带来问题，因为循环体会对调用方共享的数据结
构进行修改：
public void searchForGold(List<String> l, Stats stats){
 for(String s: l){
 if("gold".equals(s)){
 stats.incrementFor("gold");
 }
 }
}
实际上，对函数式而言，循环体带有一个无法避免的副作用：它会修改stats对象的状态，
而这和程序的其他部分是共享的。
由于这个原因，纯函数式编程语言，比如Haskell直接去除了这样的带有副作用的操作！之
后你该如何编写程序呢？比较理论的答案是每个程序都能使用无需修改的递归重写，通过这种方
式避免使用迭代。使用递归，你可以消除每步都需更新的迭代变量



