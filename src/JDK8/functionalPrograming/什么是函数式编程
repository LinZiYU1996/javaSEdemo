


对于“什么是函数式编程”这一问题最简化的回答是“它是一种使用函数进行编程的方式”。
那什么是函数呢？
我们很容易想象这样一个方法，它接受一个整型和一个浮点型参数，返回一个浮点型的结
果——它也有副作用，随着调用次数的增加，它会不断地更新共享变量，

在函数式编程的上下文中，一个“函数”对应于一个数学函数：它接受零个或多个参数，生
成一个或多个结果，并且不会有任何副作用。你可以把它看成一个黑盒，它接收输入并产生一些
输出，



函数式 Java 编程


在Java语言中，如果你希望编写函数式的程序，首先需要做的是确保没有人能觉察
到你代码的副作用，这也是函数式的含义。假设这样一个函数或者方法，它没有副作用，进入方
法体执行时会对一个字段的值加一，退出方法体之前会对该字段减一。对一个单线程的程序而言，
这个方法是没有副作用的，可以看作函数式的实现。换个角度而言，如果另一个线程可以查看该
字段的值——或者更糟糕的情况，该方法会同时被多个线程并发调用——那么这个方法就不能称
之为函数式的实现了。当然，你可以用加锁的方式对方法的方法体进行封装，掩盖这一问题，你
甚至可以再次声称该方法符合函数式的约定。但是，这样做之后，你就失去了在你的多核处理器
的两个核上并发执行两个方法调用的能力。它的副作用对程序可能是不可见的，不过对于程序员
你而言是可见的，因为程序运行的速度变慢了！



我们的准则是，被称为“函数式”的函数或方法都只能修改本地变量。除此之外，它引用的
对象都应该是不可修改的对象。通过这种规定，我们期望所有的字段都为final类型，所有的引用类型字段都指向不可变对象


我们前述的准则是不完备的，要成为真正的函数式程序还有一个附加条件，不过它在最初
时不太为大家所重视。要被称为函数式，函数或者方法不应该抛出任何异常。关于这一点，有
一个极为简单而又极为教条的解释：你不应该抛出异常，因为一旦抛出异常，就意味着结果被
终止了；不再像我们之前讨论的黑盒模式那样，由return返回一个恰当的结果值。不过，这一
规则似乎又和我们实际的数学使用有冲突：虽然合法的数学函数为每个合法的参数值返回一个
确定的结果，很多通用的数学操作在严格意义上称之为局部函数式（partial function）可能更为
妥当。这种函数对于某些输入值，甚至是大多数的输入值都返回一个确定的结果；不过对另一
些输入值，它的结果是未定义的，甚至不返回任何结果。这其中一个典型的例子是除法和开平
方运算，如果除法的第二操作数是0，或者开平方的参数为负数就会发生这样的情况。以Java那
样抛出一个异常的方式对这些情况进行建模看起来非常自然。这里存在着一定的争执，有的作
者认为抛出代表严重错误的异常是可以接受的，但是捕获异常是一种非函数式的控制流，因为
这种操作违背了我们在黑盒模型中定义的“传递参数，返回结果”的规则，引出了代表异常处
理的第三支箭头，


那么，如果不使用异常，你该如何对除法这样的函数进行建模呢？答案是请使用
Optional<T>类型：你应该避免让sqrt使用double sqrt(double)这样的函数签名，因为这
种方式可能抛出异常；与之相反我们推荐你使用Optional<Double> sqrt(double)——这种
方式下，函数要么返回一个值表示调用成功，要么返回一个对象，表明其无法进行指定的操作。
当然，这意味着调用者需要检查方法返回的是否为一个空的Optional对象。这件事听起来代价
不小，依据我们之前对函数式编程和纯粹的函数式编程的比较，从实际操作的角度出发，你可以
选择在本地局部地使用异常，避免通过接口将结果暴露给其他方法，这种方式既取得了函数式的
优点，又不会过度膨胀代码。







