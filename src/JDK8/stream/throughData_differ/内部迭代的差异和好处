


让我们用一个比喻来解释内部迭代的差异和好处吧。比方说你在和你两岁的女儿索菲亚说
话，希望她能把玩具收起来。
你：“索菲亚，我们把玩具收起来吧。地上还有玩具吗？”
索菲亚：“有，球。”
你：“好，把球放进盒子里。还有吗？”
索菲亚：“有，那是我的娃娃。”
你：“好，把娃娃放进盒子里。还有吗？”
索菲亚：“有，有我的书。”
你：“好，把书放进盒子里。还有吗？”
索菲亚：“没了，没有了。”
你：“好，我们收好啦。”

这正是你每天都要对Java集合做的。你外部迭代一个集合，显式地取出每个项目再加以处理。
如果你只需跟索菲亚说“把地上所有的玩具都放进盒子里”就好了。

内部迭代比较好的原因有二：

第一，索非亚可以选择一只手拿娃娃，另一只手拿球；
第二，她可以决定先拿离盒子最近的那个
东西，然后再拿别的。同样的道理，内部迭代时，项目可以透明地并行处理，或者用更优化的顺
序进行处理。
要是用Java过去的那种外部迭代方法，这些优化都是很困难的。这似乎有点儿鸡蛋
里挑骨头，但这差不多就是Java 8引入流的理由了——Streams库的内部迭代可以自动选择一种适
合你硬件的数据表示和并行实现。与此相反，一旦通过写for-each而选择了外部迭代，那你基
本上就要自己管理所有的并行问题了（自己管理实际上意味着“某个良辰吉日我们会把它并行化”
或“开始了关于任务和synchronized的漫长而艰苦的斗争”）。Java 8需要一个类似于
Collection却没有迭代器的接口，于是就有了Stream！












